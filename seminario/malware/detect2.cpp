#include <bits/stdc++.h>
#include <filesystem>
#include <dirent.h>
#include <unistd.h>
#include <algorithm>

using namespace std;

string trim(const string& s) {
    string result = s;
    auto start = find_if_not(s.begin(), s.end(), [](unsigned char c){return isspace(c);});
    auto end = find_if_not(s.rbegin(), s.rend(), [](unsigned char c){return isspace(c);}).base();

    if(start >= end)
        return "";

    return string(start, end);
}

unordered_set<string> load_whitelist(const string& arquivo) {
    unordered_set<string> lista;
    ifstream infile(arquivo);
    string linha;

    if(!infile.is_open()) {
        cerr << "Erro ao abrir o arquivo\n";
        return lista;
    }

    while(getline(infile, linha)) {
        if(!linha.empty()) {
            lista.insert(trim(linha));
            // cout << trim(linha) << "\n";
        }
    }

    return lista;
}

int main() {
    const string whitelist_file = "white_list.txt";
    auto execs = load_whitelist(whitelist_file);

    if(execs.empty()) {
        cerr << "Nenhum executÃ¡vel carregado!\n";
        return 1;
    }

    DIR* dir = opendir("/proc");

    if(!dir) {
        cerr << "Erro ao abrir /proc\n";
        return 1;
    }

    struct dirent* entry;
    bool flag = false;
    while((entry = readdir(dir)) != nullptr) {
        string pid_str = entry->d_name;
        string exe_path = "/proc/" + pid_str + "/exe";

        char real_path[PATH_MAX];
        ssize_t len = readlink(exe_path.c_str(), real_path, sizeof(real_path) - 1);

        if(len != -1) {
            real_path[len] = '\0';
            string caminho(real_path);
            if(execs.find(caminho) == execs.end()) {
                cout << "[!!] Processo suspeito encontrado: PID " << pid_str << " - " << caminho << "\n";
                flag = true;
            }
        }
    }

    if(!flag) {
        cout << "Nenhum processo suspeito encontrado!\n";
    }

    closedir(dir);
  return 0;
}
